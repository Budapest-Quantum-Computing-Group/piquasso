# This file uses source code from the files strawberryfields/apps/points.py from
# https://github.com/XanaduAI/strawberryfields/blob/master/strawberryfields/apps/points.py,
# Copyright 2019 Xanadu Quantum Technologies Inc. licensed under the Apache 2.0 license.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Optional, Tuple

import piquasso as pq
import numpy as np
import scipy
from thewalrus.csamples import generate_thermal_samples, rescale_adjacency_matrix_thermal


plotly_error = (
    "Plotly required for using this function. It can be installed using pip install "
    "plotly or visiting https://plot.ly/python/getting-started/#installation"
)

GREEN = "#3e9651"
RED = "#cc2529"
GREY = "#737373"
LIGHT_GREY = "#CDCDCD"
VERY_LIGHT_GREY = "#F2F2F2"

graph_node_colour = GREEN
graph_edge_colour = LIGHT_GREY
subgraph_node_colour = RED
subgraph_edge_colour = RED

graph_node_size = 14
subgraph_node_size = 16


def quantum_inspired_points_sample(K: np.ndarray, n_mean: float, n_samples: int) -> list:
    """Sample subsets of points using the permanental point process.

    Points can be encoded through a radial basis function kernel, provided in :func:`rbf_kernel`.
    Subsets of points are sampled with probabilities that are proportional to the permanent of the
    submatrix of the kernel selected by those points.

    This permanental point process is likely to sample points that are clustered together
    :cite:`jahangiri2019point`. It can be realized using a variant of Gaussian boson sampling
    with thermal states as input.

    **Example usage:**

    >>> K = np.array([[1., 0.36787944, 0.60653066, 0.60653066],
    >>>               [0.36787944, 1., 0.60653066, 0.60653066],
    >>>               [0.60653066, 0.60653066, 1., 0.36787944],
    >>>               [0.60653066, 0.60653066, 0.36787944, 1.]])
    >>> sample(K, 1.0, 10)
    [[0, 1, 1, 1],
     [0, 0, 0, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 1],
     [0, 1, 1, 0],
     [2, 0, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 1, 1],
     [0, 0, 0, 0]]

    Args:
        K (array): the positive semidefinite kernel matrix
        n_mean (float): average number of points per sample
        n_samples (int): number of samples to be generated

    Returns:
        samples (list[list[int]]): samples generated by the point process
    """
    ls, O = rescale_adjacency_matrix_thermal(K, n_mean)
    return np.array(generate_thermal_samples(ls, O, num_samples=n_samples)).tolist()


def rbf_kernel(R: np.ndarray, sigma: float) -> np.ndarray:
    r"""Calculate the RBF kernel matrix from a set of input points.

    The kernel parameter :math:`\sigma` is used to define the kernel scale. Points that are much
    further than :math:`\sigma` from each other lead to small entries of the kernel
    matrix, whereas points much closer than :math:`\sigma` generate large entries.

    The Euclidean norm is used to measure distance in this function, resulting in a
    positive-semidefinite kernel.

    **Example usage:**

    >>> R = np.array([[0, 1], [1, 0], [0, 0], [1, 1]])
    >>> rbf_kernel (R, 1.0)
    array([[1., 0.36787944, 0.60653066, 0.60653066],
           [0.36787944, 1., 0.60653066, 0.60653066],
           [0.60653066, 0.60653066, 1., 0.36787944],
           [0.60653066, 0.60653066, 0.36787944, 1.,]])

    Args:
        R (array): Coordinate matrix. Rows of this array are the coordinates of the points.
        sigma (float): kernel parameter

    Returns:
        K (array): the RBF kernel matrix
    """
    return np.exp(-((scipy.spatial.distance.cdist(R, R)) ** 2) / 2 / sigma ** 2)


def permanent_points_sample(K: np.ndarray, size: int, n_mean: float, n_samples: int) -> list:
    ls, O = rescale_adjacency_matrix_thermal(K, 16)

    with pq.Program() as program:
        pq.Q() | pq.Squeezing(0.5, 0.5)
        pq.Q(*range(size ** 2)) | pq.Interferometer(O)
        pq.Q() | pq.ParticleNumberMeasurement()

    state = pq.GaussianState(d=size ** 2)
    result = state.apply(program)
    state.validate()

    print(result.samples)


def points(
    R: np.ndarray,
    sample: Optional[list] = None,
    plot_size: Tuple = (500, 500),
    point_size: float = 30,
):  # pragma: no cover
    """Creates a plot of two-dimensional points given their input coordinates. Sampled
    points can be optionally highlighted among all points.

    **Example usage:**

    >>> R = np.random.normal(0, 1, (50, 2))
    >>> sample = [1] * 10 + [0] * 40  # select first ten points
    >>> plot.points(R, sample).show()

    .. image:: ../../_static/normal_pp.png
       :width: 40%
       :align: center
       :target: javascript:void(0);

    Args:
        R (np.array): Coordinate matrix. Rows of this array are the coordinates of the points.
        sample (list[int]): optional subset of sampled points to be highlighted
        plot_size (int): size of the plot in pixels, given as a pair of integers ``(x_size,
            y_size)``
        point_size (int): size of the points, proportional to its radius

    Returns:
         Figure: figure of points with optionally highlighted sample
    """
    try:
        import plotly.graph_objects as go
    except ImportError:
        raise ImportError(plotly_error)

    layout = go.Layout(
        showlegend=False,
        hovermode="closest",
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        margin=dict(b=0, l=0, r=0, t=25),
        height=plot_size[1],
        width=plot_size[0],
        plot_bgcolor="white",
    )

    p = go.Scatter(
        x=R[:, 0],
        y=R[:, 1],
        mode="markers",
        hoverinfo="text",
        marker=dict(
            color=VERY_LIGHT_GREY, size=point_size, line=dict(color="black", width=point_size / 20)
        ),
    )

    p.text = [str(i) for i in range(len(R))]

    if sample:
        s_x = []
        s_y = []
        sampled_points = [i for i in range(len(sample)) if sample[i] > 0]
        for i in sampled_points:
            s_x.append(R[i, 0])
            s_y.append(R[i, 1])

        samp = go.Scatter(
            x=s_x,
            y=s_y,
            mode="markers",
            hoverinfo="text",
            marker=dict(
                color=RED, size=point_size, line=dict(color="black", width=point_size / 20)
            ),
        )

        samp.text = [str(i) for i in sampled_points]

        f = go.Figure(data=[p, samp], layout=layout)

    else:
        f = go.Figure(data=[p], layout=layout)

    return f
